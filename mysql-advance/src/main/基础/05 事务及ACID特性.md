#### 1.事务的状态
Active Commit Failed，其它的中间态对外是不可见的
#### 1.1 事务的ACID属性
为保证数据库的一致性，在事务处理之前和之后，都要遵循某些属性，也就是大家耳熟能详的ACID属性
* 原子性（Atomicity）:即不可分割性，事务中的操作要么全不做，要么全做
* 一致性（Consistency）:一个事务在执行前后，数据库必须满足正确的状态，满足完整性约束
* 隔离性（Isolation）:多个事务并发执行时，一个事务的执行不应该影响其它事务的执行
* 持久性（Durability）:事务处理完成后，对数据的修改是永久性的，即便系统故障也不会丢失

并非任意的对数据库的操作序列都是数据库事务。ACID属性是一系列操作组成事务的必要条件。总体而言，ACID属性提供了一种机制，
使每个事务都”作为一个单元，完成一组操作，产生一致结果，事务彼此隔离，更新永久生效“，从而来确保数据库的正确性和一致性。
##### 1.1.1原子性（Atomicity）
undo log，它是一种回滚日志，既可以用来实现隔离性MVCC，也可以保证原子性。
实现原子性的关键，是事务回滚时能够撤销所有已经成功执行的sql语句。
当事务对数据库进行修改时，InnoDB会生成对应的undo log，undo log会保存事务开始前老版本的数据，当事务发生异常，便会rollback回滚到老版本状态。
当发生回滚时，InnoDB会根据undo log的内容做相反逻辑操作。
insert语句，回滚时会执行 delete;
delete语句，回滚时会执行insert;
update语句，回滚时便执行相反的update，把数据改回来。
它涉及以下两个操作：
* 终止：如果事务终止，则看不到对数据库所做的更改
* 提交：如果事务提交，则所做的更改可见
拿转账的例子来说，用户A给用户B转账，至少要包含两个操作，用户A钱数减少，用户B钱数增加，增加和减少的操作要么全部成功，要么全部失败，是一个原子操作
##### 1.1.2 一致性（Consistency）
一致性是事务追求的最终目标，原子性、持久性和隔离性，其实都是为了保证数据库状态的一致性。
一致性是指，一个事务必须使数据库从一个状态变换到另一个状态（执行成功），或回滚到原始状态（执行失败）。这意味着必须维护完整性约束，以使在事务之前和之后
是对内一致性。但数据的一致性问题并不都和原子性有关。比如转账的过程中，用户A扣款了100，而用户B只收款了50，那么该过程可以符合原子性，但是数据的一致性就出现了问题
数据库保持一致性和正确性。
* 一致性既是事务的属性，也是事务的目的
* 一致性是事务ACID四大特性中最重要的属性，而原子性、隔离性和持久性，都是作为保障一致性的手段。事务作为这些性质的载体，实现了这种由ACID保障C的机制
##### 1.1.3 隔离性（Isolation）
锁+MVCC
隔离性是指，并发执行的各个事务之间不能互相干扰，即一个事务内部的操作及使用的数据，对并发的其他事务是隔离的
* 在一个事务执行过程中，数据的中间的（可能不一致）状态不应该被暴露给所有的其他事务。
* 两个并发的事务应该不能操作同一项数据。数据库管理系统通常使用锁来实现这个特征。

##### 1.1.4 持久性（Durability）
redo log，是一种物理日志。我们再更新数据库时，先将更新操作记录在redo log日志，等redo log满了或则MYSQL空闲了再刷盘。
即：许多数据库通过引入预写式日志（Write-ahead logging，缩写 WAL）机制，来保证事务持久性和数据完整性，同时又很大程度上避免了基于事务直接刷新数据的频繁IO对性能的影响。
特性：空间一定，写完会循环写。有两个指针，
"在使用WAL的系统中，所有的修改都先被写入到日志中，然后再被应用到系统状态中。假设一个程序在执行某些操作的过程中机器掉电了。在重新启动时，程序可能需要知道当时执行的操作是成功了还是部分成功或者是失败了。如果使用了WAL，
程序就可以检查log文件，并对突然掉电时计划执行的操作内容跟实际上执行的操作内容进行比较。在这个比较的基础上，程序就可以决定是撤销已做的操作还是继续完成已做的操作，或者是保持原样。"
#### 2 并发事务处理带来的问题
1. 脏读：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。
概括为：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求
2. 不可重复读： 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现 其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。
概括为：事务A读取到了事务B已经提交的修改的数据。
3. 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
概括为：事务A读取到了事务B提交的新增数据，不符合隔离性
#### 3 事务隔离级别

| 隔离级别 | 脏读 |不可重复读  | 幻读 |  
| --- | --- | --- | --- |
| 读未提交(Read Uncommitted) | 可能 | 可能  | 可能 | 
| 读已提交(Read Committed) | 不可能 |  可能 |  可能 |  
| 可重复读（Repeatable Read） | 不可能 | 不可能 |  可能|  
| 串行读（Serializable） | 不可能 | 不可能 | 不可能 |  
数据库事务隔离级别越严格，并发的副作用越小，但是“并发能力”就越差
常看当前数据库的事务隔离级别: show variables like 'tx_isolation';
设置事务隔离级别：set tx_isolation='REPEATABLE-READ';











