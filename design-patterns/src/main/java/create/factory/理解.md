#### 简单工厂
上面的工厂实现是一个具体的类PizzaFactory，而非接口或者抽象类，createPizza()方法利用if-else创建并返回具体的披萨，如果增加新的披萨子类，
工厂的创建方法中就要增加新的if-else。这种做法扩展性差，违背了开闭原则，也影响了可读性。所以，这种方式使用在业务较简单，工厂类不会经常更改的情况
#### 工厂方法
每一种键盘品牌对应一个工厂子类，在创建具体键盘对象时，实例化不同的工厂子类。
但是，如果业务涉及的子类越来越多，难道每一个子类都要对应一个工厂类吗？这样会使得系统中类的个数成倍增加，增加了代码的复杂度

#### 抽象工厂-多个工厂方法
增加分组非常简单，例如要增加Lenovo分组，只需创建Lenovo工厂和具体的产品实现类。
分组中的产品扩展非常困难，要增加一个鼠标Mouse，既要创建抽象的Mouse接口, 又要增加具体的实现：DellMouse、HPMouse， 还要再每个Factory中定义创建鼠标的方法实现。



### 总结
简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。
工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。
抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量

